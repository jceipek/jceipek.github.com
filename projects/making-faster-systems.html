<!doctype html><html lang=en><meta charset=utf-8><meta content="IE=edge,chrome=1" http-equiv=X-UA-Compatible><meta name=viewport content="width=device-width,initial-scale=.6,maximum-scale=.6,user-scalable=0"><title>Julian Ceipek | Making Faster Systems</title>
<meta name=robots content="index, follow"><meta name=generator content="Hugo 0.121.1"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#00aba9"><meta name=theme-color content="#ffffff"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Dosis:wght@400;500&family=Open+Sans:ital,wght@0,400;0,600;1,400&family=Source+Code+Pro&display=swap" rel=stylesheet><link rel=stylesheet href=/css/normalize.min.6dec53ee20f5bc2905289325994cab42171978d2d264472563bf2e1eab0da1cd.css><link rel=stylesheet href=/css/main.min.de7c17c2a3bacf501fe564a802f209b5f9625b3dedd0bcbf5478368943821145.css><body><div class=header-container><div class=header><div class=greeting><p>Hi, I'm</p><h1 class=name><span class=name--first>Julian</span> <span class=name--last>Ceipek</span></h1><div class=mission><p>I &#9829; learning, collaborating & teaching.</p><p>I craft systems with & for people.</p></div></div></div></div><div class=links-container><div class=links><a class='circle circle--small circle--left' href=https://github.com/jceipek><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%2266%22%20height=%2266%22%3E%3Cpath%20d=%22M32.997%201.79C15.329%201.79%201%2016.117%201%2033.79c0%2014.139%209.168%2026.132%2021.884%2030.363%201.601.295%202.185-.693%202.185-1.542.0-.76-.028-2.772-.044-5.441-8.9%201.933-10.779-4.29-10.779-4.29-1.455-3.698-3.553-4.682-3.553-4.682-2.906-1.984.22-1.945.22-1.945%203.212.226%204.901%203.299%204.901%203.299%202.854%204.89%207.49%203.477%209.313%202.658.291-2.067%201.118-3.478%202.032-4.277-7.106-.807-14.577-3.554-14.577-15.816.0-3.493%201.248-6.351%203.295-8.587-.33-.809-1.428-4.064.314-8.468.0.0%202.686-.86%208.799%203.28%202.552-.71%205.29-1.064%208.011-1.078%202.719.014%205.455.367%208.011%201.078%206.11-4.14%208.791-3.28%208.791-3.28%201.746%204.404.648%207.66.32%208.468%202.051%202.236%203.289%205.094%203.289%208.587.0%2012.294-7.483%2014.999-14.61%2015.79%201.147.989%202.17%202.941%202.17%205.925.0%204.279-.039%207.73-.039%208.78.0.856.578%201.852%202.2%201.54C55.84%2059.91%2065%2047.924%2065%2033.79c0-17.673-14.329-32-32.003-32%22%20fill=%22%23fff%22%20fill-rule=%22evenodd%22/%3E%3C/svg%3E">
<span>github</span>
</a><a class='circle circle--small circle--center' href=/documents/Julian_Ceipek_Resume_12_30_2023.pdf><img style=margin-top:.6em src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%2266%22%20height=%2266%22%3E%3Cpath%20d=%22M13.064.5C9.871.5%207.289%203.051%207.289%206.245v53.48a5.77%205.77.0%20005.775%205.775h39.872a5.77%205.77.0%20005.775-5.775V6.245C58.711%203.05%2056.129.5%2052.936.5H13.064zm.061%204.24h7.188c.956.0%201.72.764%201.72%201.72v6.758c0%20.956-.764%201.72-1.72%201.72h-7.188c-.956.0-1.72-.764-1.72-1.72V6.46c0-.956.764-1.72%201.72-1.72zm12.38%206.266h19.352c.824.0%201.475.65%201.475%201.474s-.651%201.475-1.475%201.475H25.505c-.824.0-1.505-.65-1.505-1.475.0-.823.681-1.474%201.505-1.474zm-8.786%209.922h22.363c.824.0%201.505.681%201.505%201.505.0.824-.681%201.475-1.505%201.475H16.72c-.823.0-1.474-.651-1.474-1.475s.65-1.505%201.474-1.505zm5.345%204.945h23.254c.577.0%201.044.468%201.044%201.045.0.576-.467%201.014-1.044%201.014H22.064c-.576.0-1.044-.438-1.044-1.014.0-.577.468-1.045%201.044-1.045zm-5.345%207.895h22.363c.824.0%201.505.681%201.505%201.505.0.824-.681%201.475-1.505%201.475H16.72c-.823.0-1.474-.651-1.474-1.475s.65-1.505%201.474-1.505zm5.345%204.946h23.254a1.045%201.045.0%20010%202.088H22.064a1.045%201.045.0%20010-2.088zm-5.345%207.925h22.363c.824.0%201.505.65%201.505%201.474s-.681%201.505-1.505%201.505H16.72c-.823.0-1.474-.68-1.474-1.505.0-.824.65-1.474%201.474-1.474zm5.345%204.915h23.254a1.045%201.045.0%20010%202.089H22.064a1.045%201.045.0%20010-2.09z%22%20fill=%22%23fff%22/%3E%3C/svg%3E">
<span>resume</span>
</a><a class='circle circle--small circle--right' href=mailto:julian.ceipek@gmail.com><img style=margin-bottom:-.2em src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%2266%22%20height=%2266%22%3E%3Cpath%20d=%22M7.11%208.844c-3.09.0-5.563%202.503-5.563%205.593v.782l.875.469%2031.375%2016.687%2029.437-15.469%201.22-.625v-1.844c0-3.09-2.473-5.593-5.563-5.593zM1.546%2019.625v31.938c0%203.09%202.472%205.593%205.562%205.593H58.89c3.09.0%205.562-2.503%205.562-5.593V20.688l-29.75%2015.656-.937.469-.907-.5z%22%20fill=%22%23fff%22/%3E%3C/svg%3E">
<span>contact</span></a></div></div><div id=content><div class=project-expl-container><a href=/><img src=/icons/left-icon.png>All projects</a><div class=project-expl><span class='img-container img-container--dark'><picture><source type=image/webp srcset="/projects/making-faster-systems/thumb_hu180f5568b5d872e38ce90529f6e1904c_723579_600x0_resize_q75_h2_box_3.webp 600w, /projects/making-faster-systems/thumb_hu180f5568b5d872e38ce90529f6e1904c_723579_1200x0_resize_q75_h2_box_3.webp 1200w, /projects/making-faster-systems/thumb_hu180f5568b5d872e38ce90529f6e1904c_723579_0x0_q75_h2__3.webp 1920w" sizes=284px><img srcset="/projects/making-faster-systems/thumb_hu180f5568b5d872e38ce90529f6e1904c_723579_600x0_resize_q75_bgffffff_box_3.jpg 600w, /projects/making-faster-systems/thumb_hu180f5568b5d872e38ce90529f6e1904c_723579_1200x0_resize_q75_bgffffff_box_3.jpg 1200w, /projects/making-faster-systems/thumb.png 1920w" src=/projects/making-faster-systems/thumb_hu180f5568b5d872e38ce90529f6e1904c_723579_600x0_resize_q75_bgffffff_box_3.jpg sizes=284px></picture></span><h2>Making Faster Systems</h2><span class=project-tagline></span>
<span class=project-roles></span><div class=project-about><p><em>This essay is inspired by a 2023 in-person presentation I gave to an audience of software, mechanical, and electrical engineers. While its examples are software-related, the principles apply across domains.</em></p><p>In
<a href=https://web.archive.org/web/20160405103933/http://www.univasf.edu.br/~marcus.ramos/pc-2008-2/p261-knuth.pdf target=_blank><em>Structured Programming with <code>go to</code> Statements</em></a>, Donald E. Knuth wrote &ldquo;&mldr;premature optimization is the root of all evil&rdquo;, and people have been misquoting him ever since. They tend to miss both what he meant by &ldquo;premature&rdquo; and what has changed since he wrote those words in 1974.</p><p>But I&rsquo;ll get back to that. First, let&rsquo;s consider <em>why</em> we might want to make faster systems:</p><ol><li>It leads to happier customers &mdash; people generally don&rsquo;t like waiting for things, and fast systems lead to fast feedback loops.</li><li>It leads to happier companies &mdash; happier customers ideally lead to higher profits. In the case of client-server software, companies pay for the resources they use, and faster systems tend to use fewer resources. What company <em>doesn&rsquo;t</em> want to decrease their cloud spend?</li><li>It leads to a happier planet &mdash; reducing resource consumption reduces environmental impact.</li><li>It leads to a happier <em>you</em>, because making systems faster is fun and rewarding.</li></ol><p>For a concrete example of why making faster systems matters, consider my work at Lumafield: reducing the time to inspect products from hours to under a minute allowed the company to serve customers in entirely new market segments (see
<a href=/projects/x-ray-vision.html><em>Empowering Manufacturers with X-ray Vision</em></a>).</p><p>When Knuth scorned &ldquo;premature optimization,&rdquo; he was referring to the practice of making small micro-optimizations throughout a program until the code becomes impossible to understand or change. While micro-optimizations are sometimes justified, making faster systems encompasses a broad spectrum of activities.</p><p>There are three fundamental steps we need to take if we want to make faster systems:</p><ul><li><strong>Understand the Problem</strong></li><li><strong>Only Do Useful Work</strong></li><li><strong>Measure</strong></li></ul><p>Unfortunately I think they&rsquo;re too often neglected.</p><h2 id=understand-the-problem>Understand the Problem</h2><p>The purpose of human-designed systems is to solve problems. To build a fast system, we have to understand the problem we are solving, which includes understanding what we hope to achieve and the constraints under which we are operating.</p><p>At their simplest, we can think of systems as transforming inputs into outputs. Two systems with the same inputs and outputs can have vastly different performance characteristics.</p><p>We all know that nothing is faster than light. That is also true of software systems, which operate on physical computers, as much as marketing terms like &ldquo;serverless&rdquo; would have you think otherwise.</p><p>Every computer has one or more CPUs (central processing units) that process inputs into outputs. To make faster software systems, we have to understand how fast the computers that execute them are.</p><p>Computers are really fast. For example, adding two numbers together might take 0.33 nanoseconds. To put that in perspective:</p><ul><li>1000 nanoseconds = 1 microsecond</li><li>1000 microseconds = 1 millisecond</li><li>1000 milliseconds = 1 second</li></ul><p>Such a computer can perform 3,000,000,000 (3 billion) additions per lane per core per second.</p><p>If you open up a computer, take out the CPU, dunk it in a vat of hydrochloric acid, and look at it under a microscope, you&rsquo;ll see something similar to this:</p><picture><source type=image/webp srcset="/projects/making-faster-systems/die_shot_hu370740d82551e7c98589cd542e415675_6374578_600x0_resize_q75_h2_box_3.webp 600w, /projects/making-faster-systems/die_shot_hu370740d82551e7c98589cd542e415675_6374578_1200x0_resize_q75_h2_box_3.webp 1200w, /projects/making-faster-systems/die_shot_hu370740d82551e7c98589cd542e415675_6374578_0x0_q75_h2__3.webp 2782w" sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"><img alt="A die shot from an Intel Tiger Lake CPU. It looks like an aerial photo of solar panels interspersed with rectangular chemical vats in different colors, but it is only 10.7 mm on a side." srcset="/projects/making-faster-systems/die_shot_hu370740d82551e7c98589cd542e415675_6374578_600x0_resize_q75_bgffffff_box_3.jpg 600w, /projects/making-faster-systems/die_shot_hu370740d82551e7c98589cd542e415675_6374578_1200x0_resize_q75_bgffffff_box_3.jpg 1200w, /projects/making-faster-systems/die_shot.png 2782w" src=/projects/making-faster-systems/die_shot_hu370740d82551e7c98589cd542e415675_6374578_600x0_resize_q75_bgffffff_box_3.jpg sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"></picture><p>This chip (an 11th generation Intel CPU) has 4 cores:
<picture><source type=image/webp srcset="/projects/making-faster-systems/die_shot_cores_hu9649a9a792b45a95ceab8acb08d5066f_5864539_600x0_resize_q75_h2_box_3.webp 600w, /projects/making-faster-systems/die_shot_cores_hu9649a9a792b45a95ceab8acb08d5066f_5864539_1200x0_resize_q75_h2_box_3.webp 1200w, /projects/making-faster-systems/die_shot_cores_hu9649a9a792b45a95ceab8acb08d5066f_5864539_0x0_q75_h2__3.webp 2359w" sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"><img alt="The die shot from before, with annotations showing 4 repeated structures labeled as " cores"." srcset="/projects/making-faster-systems/die_shot_cores_hu9649a9a792b45a95ceab8acb08d5066f_5864539_600x0_resize_q75_bgffffff_box_3.jpg 600w, /projects/making-faster-systems/die_shot_cores_hu9649a9a792b45a95ceab8acb08d5066f_5864539_1200x0_resize_q75_bgffffff_box_3.jpg 1200w, /projects/making-faster-systems/die_shot_cores.png 2359w" src=/projects/making-faster-systems/die_shot_cores_hu9649a9a792b45a95ceab8acb08d5066f_5864539_600x0_resize_q75_bgffffff_box_3.jpg sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"></picture></p><p>The parts of each core that perform addition are the execution units, and they&rsquo;re connected to a series of memory caches:</p><picture><source type=image/webp srcset="/projects/making-faster-systems/die_shot_journey_hu52b1ef2be3f4f631104f5ebda3508000_4567539_600x0_resize_q75_h2_box_3.webp 600w, /projects/making-faster-systems/die_shot_journey_hu52b1ef2be3f4f631104f5ebda3508000_4567539_1200x0_resize_q75_h2_box_3.webp 1200w, /projects/making-faster-systems/die_shot_journey_hu52b1ef2be3f4f631104f5ebda3508000_4567539_0x0_q75_h2__3.webp 2360w" sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"><img alt="The die shot from before, now annotated with colorful blocks showing the execution units, L1 data cache, L1 instruction cache, L2 cache, and L3 cache for one of the cores. The annotations are connected with lines to show that they are connected with a path that leads to main memory, which is far away from the execution units." srcset="/projects/making-faster-systems/die_shot_journey_hu52b1ef2be3f4f631104f5ebda3508000_4567539_600x0_resize_q75_bgffffff_box_3.jpg 600w, /projects/making-faster-systems/die_shot_journey_hu52b1ef2be3f4f631104f5ebda3508000_4567539_1200x0_resize_q75_bgffffff_box_3.jpg 1200w, /projects/making-faster-systems/die_shot_journey.png 2360w" src=/projects/making-faster-systems/die_shot_journey_hu52b1ef2be3f4f631104f5ebda3508000_4567539_600x0_resize_q75_bgffffff_box_3.jpg sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"></picture><p>When adding numbers, if the execution units have already loaded the numbers to add, addition can be really fast. If they don&rsquo;t, they have to fetch them from the small nearby piece of memory called the L1 data cache. If the L1 cache doesn&rsquo;t have the numbers, they have to fetch them from the larger L2 cache. If the L2 cache doesn&rsquo;t have the numbers, they have to fetch them from the L3 cache, which, on this chip, is shared across all 4 cores. If the L3 cache doesn&rsquo;t have the data, they have to fetch them from main memory.</p><p>Each of these involves a longer and longer physical distance to a place with more storage, and the data has to physically travel to where it is needed. Physics is a hard constraint that can&rsquo;t be ignored. Remember: nothing is faster than light.</p><p>Let&rsquo;s put these distances into perspective with a race.
When you click play in the following video, the blue boxes will move from left to right.
If they moved at their regular speeds, you wouldn&rsquo;t be able to tell their speeds apart, so I&rsquo;ve slowed everything down 1 billion times: 1 second in the video corresponds to 1 nanosecond of real time. Can you guess how long main memory access will take? What about accessing an NVMe drive (which is faster than a hard drive or SSD)?</p><p><video controls style=width:100% src=/projects/making-faster-systems/MakingFasterSystemsRace.mp4></video></p><p>To keep the video short, I&rsquo;ve summarized all the results in this table:</p><table><thead><tr><th>Activity</th><th>Actual Time</th><th>Scaled</th></tr></thead><tbody><tr><td>Add 2 numbers</td><td>0.33 ns</td><td>0.33 s</td></tr><tr><td>L1 Access</td><td>1 ns</td><td>1 s</td></tr><tr><td>L2 Access</td><td>4 ns</td><td>4 s</td></tr><tr><td>L3 Access</td><td>16 ns</td><td>16 s</td></tr><tr><td>Main Memory Access</td><td>100 ns</td><td>1.7 min</td></tr><tr><td>NVMe Drive Access</td><td>700,000 ns</td><td>8.1 days</td></tr><tr><td>BOS->SF Network Roundtrip</td><td>80,000,000 ns</td><td>2.5 years</td></tr></tbody></table><p>The specific times here don&rsquo;t really matter and come from a computer I don&rsquo;t have anymore. They&rsquo;d be different on a different computer. What matters is that they span multiple orders of magnitude, and switching to a newer computer won&rsquo;t change that. There&rsquo;s quite a lot of difference between seconds and years.</p><p>In <em>Structured Programming with <code>go to</code> Statements</em>, Knuth wrote:</p><blockquote><p>In established engineering disciplines a 12% improvement, easily obtained, is never considered marginal; and I believe the same viewpoint should prevail in software engineering.</p></blockquote><p>What do you think he would say about a 10,000+% improvement (having the numbers in the L1 cache vs fetching them from memory)?</p><p>He was writing in 1974, when memory and processor speed were about the same. Since then, the gap between processor and memory speed has grown many orders of magnitude apart, and we can&rsquo;t ignore that if we want to create fast software.</p><figure><picture><source type=image/webp srcset="/projects/making-faster-systems/processor_memory_gap_hu01f50ae24638bc1bf175c4195d8a0684_623869_600x0_resize_q75_h2_box_3.webp 600w, /projects/making-faster-systems/processor_memory_gap_hu01f50ae24638bc1bf175c4195d8a0684_623869_1200x0_resize_q75_h2_box_3.webp 1200w, /projects/making-faster-systems/processor_memory_gap_hu01f50ae24638bc1bf175c4195d8a0684_623869_0x0_q75_h2__3.webp 2394w" sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"><img alt="Chart showing the processor-memory gap. Processor and memory performance start out similar in 1980 and then diverge sharply on a log plot. As of 2015, memory performance is at 10 and processor performance is at 10,000. Both numbers are unitless." srcset="/projects/making-faster-systems/processor_memory_gap_hu01f50ae24638bc1bf175c4195d8a0684_623869_600x0_resize_q75_bgffffff_box_3.jpg 600w, /projects/making-faster-systems/processor_memory_gap_hu01f50ae24638bc1bf175c4195d8a0684_623869_1200x0_resize_q75_bgffffff_box_3.jpg 1200w, /projects/making-faster-systems/processor_memory_gap.png 2394w" src=/projects/making-faster-systems/processor_memory_gap_hu01f50ae24638bc1bf175c4195d8a0684_623869_600x0_resize_q75_bgffffff_box_3.jpg sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"></picture><figcaption>(chart from <cite><a href=https://archive.org/details/computerarchitectureaquantitativeapproach6thedition/page/n111/mode/1up target=_blank>Computer Architecture: A Quantitative Approach, 6th Edition, page 80</a></cite>)</figcaption></figure><p>In 1974, Knuth&rsquo;s programs executed almost directly on the CPU. A typical web application today has many more layers between its code and the CPU, including an operating system (30 million lines of code), a browser (26 million lines of code) with a virtual machine, and likely 10s-100s of 3rd party libraries running on end users&rsquo; computers. It likely also involves many more computers spread across datacenters throughout the world, each with their own layers of software. There are many more choices to make, and programmers need to understand the soft constraints imposed by those choices and the choices of the people who use their software. Even if the problem they are solving calls for a web application (not all problems call for a web application!), programmers and the people they work with can still decide the programming languages and 3rd party libraries they use, the code they write themselves, and on which computers the code runs. Every decision has consequences.</p><h2 id=only-do-useful-work>Only Do Useful Work</h2><p>Once we&rsquo;ve understood the problem, we can use our understanding to minimize waste. The fastest thing is doing nothing. The fastest <em>useful</em> thing is doing nothing unneeded.</p><p>To illustrate this, I&rsquo;ll use a case study from a web project where I needed to find the brightest and darkest pixels in a user-specified region of an image. The inputs were the compressed image in main memory and the coordinates of the region. The desired outputs were the brightest and darkest pixel of the image.</p><p>When faced with a problem like this, I like to think about the simplest way of getting from the inputs to the outputs. This might not be the fastest way, but simple code with few dependencies is the easiest code to change.</p><p>In this case, the simplest approach I could think of was:</p><ol><li>Decompress the compressed image</li><li>Sequentially look at every pixel in the user-specified region, recording the brightest and darkest pixels found so far</li></ol><p>The code I inherited looked like this:</p><ol><li>Decompress the compressed image to main memory</li><li>Upload the decompressed image to graphics memory</li><li>Download the image from graphics memory</li><li>Upload the image to graphics memory</li><li>Create a copy of the pixels in the user-specified region</li><li>Sort the copied pixels by brightness</li><li>Retrieve the brightest and darkest pixels from the sorted copy</li></ol><p>This code had passed code review. Its code style followed &ldquo;industry best practices.&rdquo; Unfortunately, those practices failed to produce code that minimized waste and was easy to understand and change. Improving these practices is a topic for a future article.</p><p>After my improvements, the code looked like this:</p><ol><li>Decompress the compressed image to main memory</li><li>Upload the image to graphics memory</li><li>Download the image from graphics memory</li><li>Sequentially search the pixels in the user-specified region for the brightest and darkest pixels</li></ol><p>This is not quite the simple strategy I wanted, but it was the best I could do given the problem constraints &mdash; it had to run in a web browser. The browser did not provide a way to directly access the image pixels after decompressing the image, so I needed to upload and download the image from graphics memory first. Nonetheless, my implementation was several times faster than the original.</p><p>Contrast this with a different (yet unfortunately common) strategy: if I had timed the original program, I might have found that the slowest individual part was sorting the pixels. I might have tried to replace the sorting algorithm with a faster, &ldquo;optimized&rdquo; algorithm for this application. That would have been a mistake, because sorting wasn&rsquo;t necessary in the first place. Why waste time trying to make an unnecessary thing faster when you can remove it instead? <em>Nothing</em> is always faster than light.</p><p>Let&rsquo;s return to Knuth&rsquo;s &ldquo;&mldr;premature optimization is the root of all evil.&rdquo; Many people use this quote to justify ignoring performance altogether until it becomes a problem, with the aim of maximizing productivity. In my experience, such a strategy inevitably backfires, resulting instead in an ever-growing productivity drain interspersed with heroic rewrite efforts.</p><h2 id=measure>Measure</h2><p>Measuring is crucial for making faster systems. It lets us understand how fast our systems are in practice, which lets us make comparisons:</p><ol><li>We can compare two systems to understand which is faster.</li><li>If we can estimate the theoretical optimal speed of a system, we can compare that estimate to our real system&rsquo;s speed to understand how much better it could be with additional effort.</li></ol><p>With comparisons in hand, we can iterate. When we make changes,</p><ol><li>how much faster or slower is the new system than the old one?</li><li>how close is our new system to the theoretical top speed?</li></ol><p>When measuring &ldquo;speed&rdquo;, it&rsquo;s important to differentiate <em>latency</em> (how long it takes to do something) from <em>throughput</em> (how many of those things you can do in a given timeframe). To understand the difference between latency and throughput, think of a laundromat. If a laundromat has 3 washing machines that each take 1 hour to wash a load of laundry, it will take no less than 1 hour to wash 1 load of laundry. The latency is 1 hour. Adding washing machines won&rsquo;t make it go faster, but a faster washing machine would. However, with 3 machines, you can wash up to 3 loads of laundry at the same time. The throughput is 3 loads/hour.</p><p>For the rest of this section, I&rsquo;ll use latency measurements from the &ldquo;brain&rdquo; of a reactive robotic display case I programmed in 2018. Among other things, the brain was responsible for deciding the colors of 1189 individual LEDs, 30 times per second (once every 33 milliseconds) using a slow $35 computer. In this problem, the throughput was fixed &mdash; the brain always needed to update all 1189 LEDs &mdash; and the maximum acceptable latency was 33 milliseconds. Unfortunately, determining the colors was the slowest part of the program and by itself took over 100 milliseconds on the $35 computer. I needed to make it much faster. How did I know to focus on this part of the program? I used profiling tools.</p><blockquote><p>&ldquo;It is often a mistake to make a priori judgments about what parts of a program are really critical, since the universal experience of programmers who have been using measurement tools has been that their intuitive guesses fail.&rdquo;</p><p>&ndash; Knuth</p></blockquote><p>Profiling tools often produce icicle graphs &mdash; visualizations that show how long different parts of a process take using labeled rectangles arranged such that substeps are lower down than the steps that depend on them. In this icicle graph (produced using
<a href=https://github.com/gaogaotiantian/viztracer target=_blank>viztracer</a> and
<a href=https://gravitymoth.com/spall/spall-web.html target=_blank>Spall</a> on my fast 2019 laptop), we can see that <code>animationStep</code> is a substep of <code>animationTick</code>, which is itself a substep of <code>_run</code>. The yellow rectangles labeled <code>animationStep</code> are wide, which suggests that the program is spending a lot of time in <code>animationStep</code> (around 50 milliseconds with profiler overhead).
<picture><source type=image/webp srcset="/projects/making-faster-systems/animation_step_icicle_profile_hufe1346016932a902f0cc347aef510902_524199_600x0_resize_q75_h2_box_3.webp 600w, /projects/making-faster-systems/animation_step_icicle_profile_hufe1346016932a902f0cc347aef510902_524199_1200x0_resize_q75_h2_box_3.webp 1200w, /projects/making-faster-systems/animation_step_icicle_profile_hufe1346016932a902f0cc347aef510902_524199_0x0_q75_h2__3.webp 3048w" sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"><img alt="Profiling results showing many colorful stacked rectangles forming an icicle graph. The yellow rectangles labeled " animationstep" are clearly wide when compared with most of the other rectangles." srcset="/projects/making-faster-systems/animation_step_icicle_profile_hufe1346016932a902f0cc347aef510902_524199_600x0_resize_q75_bgffffff_box_3.jpg 600w, /projects/making-faster-systems/animation_step_icicle_profile_hufe1346016932a902f0cc347aef510902_524199_1200x0_resize_q75_bgffffff_box_3.jpg 1200w, /projects/making-faster-systems/animation_step_icicle_profile.png 3048w" src=/projects/making-faster-systems/animation_step_icicle_profile_hufe1346016932a902f0cc347aef510902_524199_600x0_resize_q75_bgffffff_box_3.jpg sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"></picture></p><p>When I first started practicing optimization, my approach was to measure the latency of an existing system, make some changes, measure again, and discard the changes if the newer measurement was slower. I notice many other people do this as well. This is a mistake.</p><p>If I measure three different implementations of <code>animationTick</code> once, I might get the following latencies:</p><ul><li>A (the implementation above, without profiler overhead): 20.9 milliseconds</li><li>B: 0.58 milliseconds</li><li>C: 1.97 milliseconds</li></ul><p>It seems like B is faster than C is much faster than A. But plotting thousands of runs for each implementation tells a different story:
<picture><source type=image/webp srcset="/projects/making-faster-systems/scatterplots_abc_hu7f2e4bdfc751f085b796be685045e6c7_541212_600x0_resize_q75_h2_box_3.webp 600w, /projects/making-faster-systems/scatterplots_abc_hu7f2e4bdfc751f085b796be685045e6c7_541212_1200x0_resize_q75_h2_box_3.webp 1200w, /projects/making-faster-systems/scatterplots_abc_hu7f2e4bdfc751f085b796be685045e6c7_541212_0x0_q75_h2__3.webp 1426w" sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"><img alt="A scatterplot comparing the latency of 5000 runs of implementations A, B, and C. A is clearly slow and very jittery. Most of its points are above 20ms. B and C's points are usually below 3 ms." srcset="/projects/making-faster-systems/scatterplots_abc_hu7f2e4bdfc751f085b796be685045e6c7_541212_600x0_resize_q75_bgffffff_box_3.jpg 600w, /projects/making-faster-systems/scatterplots_abc_hu7f2e4bdfc751f085b796be685045e6c7_541212_1200x0_resize_q75_bgffffff_box_3.jpg 1200w, /projects/making-faster-systems/scatterplots_abc.png 1426w" src=/projects/making-faster-systems/scatterplots_abc_hu7f2e4bdfc751f085b796be685045e6c7_541212_600x0_resize_q75_bgffffff_box_3.jpg sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)">
</picture><picture><source type=image/webp srcset="/projects/making-faster-systems/scatterplot_callouts_bc_hu65e244d7be5254faf7920b2c2815405f_798873_600x0_resize_q75_h2_box_3.webp 600w, /projects/making-faster-systems/scatterplot_callouts_bc_hu65e244d7be5254faf7920b2c2815405f_798873_1200x0_resize_q75_h2_box_3.webp 1200w, /projects/making-faster-systems/scatterplot_callouts_bc_hu65e244d7be5254faf7920b2c2815405f_798873_0x0_q75_h2__3.webp 1471w" sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"><img alt="A zoomed-in version of the previous scatterplot, comparing latencies for B and C. While B is usually faster than C, the plot is annotated with two samples where that isn't the case." srcset="/projects/making-faster-systems/scatterplot_callouts_bc_hu65e244d7be5254faf7920b2c2815405f_798873_600x0_resize_q75_bgffffff_box_3.jpg 600w, /projects/making-faster-systems/scatterplot_callouts_bc_hu65e244d7be5254faf7920b2c2815405f_798873_1200x0_resize_q75_bgffffff_box_3.jpg 1200w, /projects/making-faster-systems/scatterplot_callouts_bc.png 1471w" src=/projects/making-faster-systems/scatterplot_callouts_bc_hu65e244d7be5254faf7920b2c2815405f_798873_600x0_resize_q75_bgffffff_box_3.jpg sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"></picture></p><p>While A is consistently slower, there&rsquo;s enough overlap between B and C that comparing single measurements of each could make it seem like B is faster than C, even though it usually isn&rsquo;t.</p><p>Trying to avoid this trap, many people turn to average measurements. Unfortunately, averages obscure the distribution of data. In fact, vastly different datasets can have the same average, variance, and correlation (see
<a href=https://web.archive.org/web/20230829104458/https://blog.revolutionanalytics.com/2017/05/the-datasaurus-dozen.html target=_blank>the Datasaurus Dozen</a>). In most applications, latency outliers matter. You wouldn&rsquo;t want a washing machine that takes an hour to wash your clothes on average but takes an entire day 10% of the time. After an update, my favorite podcast app sometimes took up to 3 seconds to respond when I tapped the play/pause button. I no longer use that app.</p><p>Here, the B average of 1.21 milliseconds completely hides the latency outlier at 3.59 milliseconds:
<picture><source type=image/webp srcset="/projects/making-faster-systems/scatterplot_bc_average_hud5cc261fd669c09f712c748508c589a8_795928_600x0_resize_q75_h2_box_3.webp 600w, /projects/making-faster-systems/scatterplot_bc_average_hud5cc261fd669c09f712c748508c589a8_795928_1200x0_resize_q75_h2_box_3.webp 1200w, /projects/making-faster-systems/scatterplot_bc_average_hud5cc261fd669c09f712c748508c589a8_795928_0x0_q75_h2__3.webp 1462w" sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"><img alt="The previous scatterplot annotated with the average latency for B. The average is clearly slower than most of the points and describes none of them." srcset="/projects/making-faster-systems/scatterplot_bc_average_hud5cc261fd669c09f712c748508c589a8_795928_600x0_resize_q75_bgffffff_box_3.jpg 600w, /projects/making-faster-systems/scatterplot_bc_average_hud5cc261fd669c09f712c748508c589a8_795928_1200x0_resize_q75_bgffffff_box_3.jpg 1200w, /projects/making-faster-systems/scatterplot_bc_average.png 1462w" src=/projects/making-faster-systems/scatterplot_bc_average_hud5cc261fd669c09f712c748508c589a8_795928_600x0_resize_q75_bgffffff_box_3.jpg sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"></picture></p><p>The median is not totally useless. While it still hides outliers, it tells us the latency that 50% of runs were faster (and slower) than:
<picture><source type=image/webp srcset="/projects/making-faster-systems/scatterplot_bc_median_average_hufbc9befaba3bdc9ffcd1edd9ee6f094d_800280_600x0_resize_q75_h2_box_3.webp 600w, /projects/making-faster-systems/scatterplot_bc_median_average_hufbc9befaba3bdc9ffcd1edd9ee6f094d_800280_1200x0_resize_q75_h2_box_3.webp 1200w, /projects/making-faster-systems/scatterplot_bc_median_average_hufbc9befaba3bdc9ffcd1edd9ee6f094d_800280_0x0_q75_h2__3.webp 1462w" sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"><img alt="The previous scatterplot annotated with the average and median latency for B. The median clearly captures most of the points, but there are many points above and below it." srcset="/projects/making-faster-systems/scatterplot_bc_median_average_hufbc9befaba3bdc9ffcd1edd9ee6f094d_800280_600x0_resize_q75_bgffffff_box_3.jpg 600w, /projects/making-faster-systems/scatterplot_bc_median_average_hufbc9befaba3bdc9ffcd1edd9ee6f094d_800280_1200x0_resize_q75_bgffffff_box_3.jpg 1200w, /projects/making-faster-systems/scatterplot_bc_median_average.png 1462w" src=/projects/making-faster-systems/scatterplot_bc_median_average_hufbc9befaba3bdc9ffcd1edd9ee6f094d_800280_600x0_resize_q75_bgffffff_box_3.jpg sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"></picture></p><p>But what we&rsquo;re really interested in is more than we can capture in a single number (or even a few numbers). We want to understand the <em>latency distribution</em>. This is where we might be tempted to reach for histograms:
<picture><source type=image/webp srcset="/projects/making-faster-systems/histograms_bc_hufe9b0495a047158bc91c3f8d99f3a3c0_450469_600x0_resize_q75_h2_box_3.webp 600w, /projects/making-faster-systems/histograms_bc_hufe9b0495a047158bc91c3f8d99f3a3c0_450469_1200x0_resize_q75_h2_box_3.webp 1200w, /projects/making-faster-systems/histograms_bc_hufe9b0495a047158bc91c3f8d99f3a3c0_450469_0x0_q75_h2__3.webp 1468w" sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"><img alt="Two partially-overlapping histograms comparing 5000 samples of B and C, with several clearly defined peaks in each histogram." srcset="/projects/making-faster-systems/histograms_bc_hufe9b0495a047158bc91c3f8d99f3a3c0_450469_600x0_resize_q75_bgffffff_box_3.jpg 600w, /projects/making-faster-systems/histograms_bc_hufe9b0495a047158bc91c3f8d99f3a3c0_450469_1200x0_resize_q75_bgffffff_box_3.jpg 1200w, /projects/making-faster-systems/histograms_bc.png 1468w" src=/projects/making-faster-systems/histograms_bc_hufe9b0495a047158bc91c3f8d99f3a3c0_450469_600x0_resize_q75_bgffffff_box_3.jpg sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"></picture></p><p>Unfortunately, histograms require picking a size for each bin, and bins don&rsquo;t really make sense for continuous time measurements. Histograms are perfect if we want to be able to say things like &ldquo;461 of the runs with implementation B took between 1.28 and 1.29 milliseconds.&rdquo; I don&rsquo;t know about you, but that&rsquo;s not the kind of thing I&rsquo;ve ever wanted to know.
<picture><source type=image/webp srcset="/projects/making-faster-systems/histograms_labeled_bar_bc_huf3faa0b6b0a8ac9fe0aeb20fb0af7657_460512_600x0_resize_q75_h2_box_3.webp 600w, /projects/making-faster-systems/histograms_labeled_bar_bc_huf3faa0b6b0a8ac9fe0aeb20fb0af7657_460512_1200x0_resize_q75_h2_box_3.webp 1200w, /projects/making-faster-systems/histograms_labeled_bar_bc_huf3faa0b6b0a8ac9fe0aeb20fb0af7657_460512_0x0_q75_h2__3.webp 1468w" sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"><img alt="A repeat of the previous histograms, with one of the bars annotated to show the number of runs between 1.28 and 1.29 milliseconds." srcset="/projects/making-faster-systems/histograms_labeled_bar_bc_huf3faa0b6b0a8ac9fe0aeb20fb0af7657_460512_600x0_resize_q75_bgffffff_box_3.jpg 600w, /projects/making-faster-systems/histograms_labeled_bar_bc_huf3faa0b6b0a8ac9fe0aeb20fb0af7657_460512_1200x0_resize_q75_bgffffff_box_3.jpg 1200w, /projects/making-faster-systems/histograms_labeled_bar_bc.png 1468w" src=/projects/making-faster-systems/histograms_labeled_bar_bc_huf3faa0b6b0a8ac9fe0aeb20fb0af7657_460512_600x0_resize_q75_bgffffff_box_3.jpg sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"></picture></p><p>They also make it hard to answer the common questions we <em>are</em> interested in, like &ldquo;what percent of the runs with implementation B were faster than 1.2 milliseconds?&rdquo;
<picture><source type=image/webp srcset="/projects/making-faster-systems/histograms_bc_highlighted_region_hub4d96ddd636628d3e62f60182a866093_447514_600x0_resize_q75_h2_box_3.webp 600w, /projects/making-faster-systems/histograms_bc_highlighted_region_hub4d96ddd636628d3e62f60182a866093_447514_1200x0_resize_q75_h2_box_3.webp 1200w, /projects/making-faster-systems/histograms_bc_highlighted_region_hub4d96ddd636628d3e62f60182a866093_447514_0x0_q75_h2__3.webp 1468w" sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"><img alt="A repeat of the previous histograms, now highlighting the bars in the B histogram that refer to latencies below 1.2 milliseconds." srcset="/projects/making-faster-systems/histograms_bc_highlighted_region_hub4d96ddd636628d3e62f60182a866093_447514_600x0_resize_q75_bgffffff_box_3.jpg 600w, /projects/making-faster-systems/histograms_bc_highlighted_region_hub4d96ddd636628d3e62f60182a866093_447514_1200x0_resize_q75_bgffffff_box_3.jpg 1200w, /projects/making-faster-systems/histograms_bc_highlighted_region.png 1468w" src=/projects/making-faster-systems/histograms_bc_highlighted_region_hub4d96ddd636628d3e62f60182a866093_447514_600x0_resize_q75_bgffffff_box_3.jpg sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"></picture></p><p>To answer that question, we would have to add up the heights of all the bars we&rsquo;re interested in and divide by the total number of bars, which is really annoying to do by hand. Instead, we can use my favorite type of graph for latency distributions, Cumulative Distribution Functions. To produce a CDF, take an unbinned histogram and divide each bar height by the total number of bars to produce a Probability Density Function (PDF). Then plot the cumulative sum of the PDF. The result is a graph that shows all the same peaks and valleys that a histogram would:
<picture><source type=image/webp srcset="/projects/making-faster-systems/cdf_vs_histogram_bc_hubadda6972a605f62ab3e9493c7292907_284719_600x0_resize_q75_h2_box_3.webp 600w, /projects/making-faster-systems/cdf_vs_histogram_bc_hubadda6972a605f62ab3e9493c7292907_284719_1200x0_resize_q75_h2_box_3.webp 1200w, /projects/making-faster-systems/cdf_vs_histogram_bc_hubadda6972a605f62ab3e9493c7292907_284719_0x0_q75_h2__3.webp 1582w" sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"><img alt="A repeat of the previous histograms, overlaid with two lines representing the CDFs of B and C. The lines change slope wherever there are peaks and valleys in the corresponding histograms." srcset="/projects/making-faster-systems/cdf_vs_histogram_bc_hubadda6972a605f62ab3e9493c7292907_284719_600x0_resize_q75_bgffffff_box_3.jpg 600w, /projects/making-faster-systems/cdf_vs_histogram_bc_hubadda6972a605f62ab3e9493c7292907_284719_1200x0_resize_q75_bgffffff_box_3.jpg 1200w, /projects/making-faster-systems/cdf_vs_histogram_bc.png 1582w" src=/projects/making-faster-systems/cdf_vs_histogram_bc_hubadda6972a605f62ab3e9493c7292907_284719_600x0_resize_q75_bgffffff_box_3.jpg sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"></picture></p><p>More importantly, the (X, Y) coordinate tells you that Y fraction of samples were faster than X time. For example, here&rsquo;s the answer to our question from before:
<picture><source type=image/webp srcset="/projects/making-faster-systems/cdf_vs_histogram_labeled_bc_hub51f69e1bc81b41c53d6f73925b1da1b_302231_600x0_resize_q75_h2_box_3.webp 600w, /projects/making-faster-systems/cdf_vs_histogram_labeled_bc_hub51f69e1bc81b41c53d6f73925b1da1b_302231_1200x0_resize_q75_h2_box_3.webp 1200w, /projects/making-faster-systems/cdf_vs_histogram_labeled_bc_hub51f69e1bc81b41c53d6f73925b1da1b_302231_0x0_q75_h2__3.webp 1582w" sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"><img alt="A repeat of the CDF+histogram combination, annotated with two orthogonal lines intersecting to show that 31.8% of B's runs took 1.20 ms or less time." srcset="/projects/making-faster-systems/cdf_vs_histogram_labeled_bc_hub51f69e1bc81b41c53d6f73925b1da1b_302231_600x0_resize_q75_bgffffff_box_3.jpg 600w, /projects/making-faster-systems/cdf_vs_histogram_labeled_bc_hub51f69e1bc81b41c53d6f73925b1da1b_302231_1200x0_resize_q75_bgffffff_box_3.jpg 1200w, /projects/making-faster-systems/cdf_vs_histogram_labeled_bc.png 1582w" src=/projects/making-faster-systems/cdf_vs_histogram_labeled_bc_hub51f69e1bc81b41c53d6f73925b1da1b_302231_600x0_resize_q75_bgffffff_box_3.jpg sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"></picture></p><p>This is commonly written as pY for any value of Y. For example, the median is p50, the 50th percentile. If the p90 is 1.42 milliseconds, that means 90% of measurements were faster (and 10% slower) than 1.42 milliseconds.
<picture><source type=image/webp srcset="/projects/making-faster-systems/cdf_p90_p50_bc_hu443f737fc6e274210ba08372f1f1ab60_330139_600x0_resize_q75_h2_box_3.webp 600w, /projects/making-faster-systems/cdf_p90_p50_bc_hu443f737fc6e274210ba08372f1f1ab60_330139_1200x0_resize_q75_h2_box_3.webp 1200w, /projects/making-faster-systems/cdf_p90_p50_bc_hu443f737fc6e274210ba08372f1f1ab60_330139_0x0_q75_h2__3.webp 1488w" sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"><img alt="CDFs comparing 5000 runs of B and C. The B CDF is annotated with labels at two points. 90% of samples took 1.42 ms or less, while 50% of samples took 1.30 ms or less." srcset="/projects/making-faster-systems/cdf_p90_p50_bc_hu443f737fc6e274210ba08372f1f1ab60_330139_600x0_resize_q75_bgffffff_box_3.jpg 600w, /projects/making-faster-systems/cdf_p90_p50_bc_hu443f737fc6e274210ba08372f1f1ab60_330139_1200x0_resize_q75_bgffffff_box_3.jpg 1200w, /projects/making-faster-systems/cdf_p90_p50_bc.png 1488w" src=/projects/making-faster-systems/cdf_p90_p50_bc_hu443f737fc6e274210ba08372f1f1ab60_330139_600x0_resize_q75_bgffffff_box_3.jpg sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"></picture></p><p>I personally prefer to use the CCDF instead, which flips the y axis upside down. &ldquo;I only need to make this faster in 20% of cases&rdquo; makes me feel better than &ldquo;I&rsquo;m 80% of the way there.&rdquo; It&rsquo;s up to you. Just make sure to label your axes so everyone knows what kind of graph it is.</p><picture><source type=image/webp srcset="/projects/making-faster-systems/ccdf_bc_hu84b3515427e2788c9f0172ccb0342187_320678_600x0_resize_q75_h2_box_3.webp 600w, /projects/making-faster-systems/ccdf_bc_hu84b3515427e2788c9f0172ccb0342187_320678_1200x0_resize_q75_h2_box_3.webp 1200w, /projects/making-faster-systems/ccdf_bc_hu84b3515427e2788c9f0172ccb0342187_320678_0x0_q75_h2__3.webp 1488w" sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"><img alt="CCDFs comparing 5000 runs of B and C. The curves for each CCDF are flipped upside-down from the previous graph. A label shows that 20% of B's samples took 1.39 ms or longer." srcset="/projects/making-faster-systems/ccdf_bc_hu84b3515427e2788c9f0172ccb0342187_320678_600x0_resize_q75_bgffffff_box_3.jpg 600w, /projects/making-faster-systems/ccdf_bc_hu84b3515427e2788c9f0172ccb0342187_320678_1200x0_resize_q75_bgffffff_box_3.jpg 1200w, /projects/making-faster-systems/ccdf_bc.png 1488w" src=/projects/making-faster-systems/ccdf_bc_hu84b3515427e2788c9f0172ccb0342187_320678_600x0_resize_q75_bgffffff_box_3.jpg sizes="(min-width: 960px) 832px, calc(93.13vw - 43px)"></picture><p>Context always matters when interpreting data, and percentiles are no different. The CCDF above shows that about 1% of C runs are slower (99% are faster) than 0.7ms. How often does this p99 happen? Well, we know that <code>animationStep</code> runs 30 times a second, or 1800 times a minute (<code>30/second * 60 seconds/minute = 1800/minute</code>). 1% of 1800 is 18, so this happens around 18 times per minute. If someone views the display case for 3 minutes, we can expect them to encounter this latency or worse about 54 times (<code>18 * 3 = 54</code>).</p><p>For this project, neither the people viewing the display case, nor the company displaying it, nor the artists I worked with cared how long <code>animationStep</code> takes. They would have cared if the display case appeared unresponsive or jittery (which it was before my speed improvements), so it was important for me to make sure that the overall latency of the system was always low enough to prevent that. Plotting the latency of <code>animationStep</code> and making it faster was a means to that end rather than the end itself. Doing so also had knock-on benefits. It allowed us to showcase additional reactive animations, reduced the power consumption of the computer, and produced less waste heat.</p><h2 id=putting-it-all-together>Putting it All Together</h2><p>To make faster systems, start by <strong>Understanding the Problem</strong>. Identify the system inputs and outputs, and think about the hard constraints imposed by physics and the soft constraints imposed by your choices.</p><p>Then, <strong>Only Do Useful Work</strong>. Instead of complicated approaches, prefer simple solutions that are easy to understand, change, and optimize. Don&rsquo;t skip over understanding by &ldquo;optimizing&rdquo; part of the system that didn&rsquo;t need to exist in the first place. This step is not optional; it is where the biggest improvements come from.</p><p>Finally, <strong>Measure</strong>. When you make changes to your system, determine how the new system compares to the old one and how close it is to the theoretical top speed. Understand whether you care about latency, throughput, or both. Use profiling tools to identify the slow parts of the system and plot all the data to understand whether you&rsquo;re actually making improvements. CDFs and CCDFs are great tools for this. Use the problem context to understand if the system is fast enough. Events that sound rare when summarized with percentiles might happen frequently in practice.</p><p>It seems self-evident that making faster systems is about taking slow systems and speeding them up, but it doesn&rsquo;t have to be. It can also involve making a system that is faster <em>than a slow system would have been</em>. This might sound like a pedantic distinction, but I think the change in framing is important: it shifts the activity from cleaning up a mess after the fact to making better decisions.</p><p>In 1974, Knuth wrote &ldquo;&mldr;premature optimization is the root of all evil.&rdquo; Computing has changed since 1974, and many people don&rsquo;t understand what he meant by &ldquo;premature&rdquo;. Maybe it&rsquo;s time for a new phrase:</p><blockquote><p>Ignoring reality is the root of all evil.</p><p>&ndash; Julian Ceipek, 2023</p></blockquote><hr><small>Thanks to Casey Muratori, Mike Acton, and Gil Tene for teaching me new ways of thinking about software performance. Thanks to Cypress Frankenfeld, Lishan AZ, Clemens Ceipek, Elissa Ye, and Brendan Ritter for feedback on this essay.</small></div></div></div></div><footer><a class="circle circle--small circle--left circle--bottom" href=https://github.com/jceipek><img src="data:image/svg+xml,%3Csvg%20xmlns:dc=%22http://purl.org/dc/elements/1.1/%22%20xmlns:cc=%22http://creativecommons.org/ns%23%22%20xmlns:rdf=%22http://www.w3.org/1999/02/22-rdf-syntax-ns%23%22%20xmlns:svg=%22http://www.w3.org/2000/svg%22%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%2266%22%20height=%2266%22%20id=%22svg4162%22%3E%3Cdefs%20id=%22defs4164%22/%3E%3Cg%20transform=%22translate(-404.14286,-497.78245)%22%20id=%22layer1%22%3E%3Cpath%20d=%22m437.1399%20499.57232c-17.66829.0-31.99702%2014.32677-31.99702%2032.00096.0%2014.13817%209.16811%2026.13116%2021.88402%2030.3626%201.60102.29467%202.18447-.69345%202.18447-1.5421.0-.76024-.0275-2.77184-.0432-5.44153-8.90094%201.93302-10.77896-4.29037-10.77896-4.29037-1.45566-3.6971-3.55369-4.68129-3.55369-4.68129-2.90544-1.9841.22002-1.94481.22002-1.94481%203.21188.2259%204.90131%203.29831%204.90131%203.29831%202.85434%204.88953%207.49046%203.47708%209.31347%202.65791.29074-2.06661%201.11778-3.47708%202.03125-4.27661-7.10543-.8074-14.57625-3.5537-14.57625-15.81582.0-3.4928%201.24743-6.35108%203.29439-8.58663-.33003-.80936-1.42816-4.06446.31431-8.46877.0.0%202.68541-.86043%208.79879%203.28064%202.55183-.71113%205.29028-1.06473%208.01105-1.07848%202.7188.0141%205.45528.36735%208.01104%201.07848%206.10945-4.14107%208.79093-3.28064%208.79093-3.28064%201.7464%204.40431.64827%207.65941.32021%208.46877%202.05088%202.23555%203.28849%205.09383%203.28849%208.58663.0%2012.29354-7.4826%2014.9986-14.60964%2015.79028%201.14724.98811%202.17072%202.94078%202.17072%205.92479.0%204.27858-.0393%207.73013-.0393%208.77914.0.8565.57755%201.85248%202.20018%201.54013%2012.7061-4.24125%2021.86635-16.22638%2021.86635-30.36063.0-17.67419-14.32873-32.00096-32.00293-32.00096%22%20id=%22path4259-3%22%20style=%22fill:%23fff;fill-opacity:1;fill-rule:evenodd;stroke:none%22/%3E%3C/g%3E%3C/svg%3E">
<span>github</span>
</a><a class="circle circle--small circle--bottom" href=/documents/Julian_Ceipek_Resume_12_30_2023.pdf><img style=margin-top:.6em src="data:image/svg+xml,%3Csvg%20xmlns:dc=%22http://purl.org/dc/elements/1.1/%22%20xmlns:cc=%22http://creativecommons.org/ns%23%22%20xmlns:rdf=%22http://www.w3.org/1999/02/22-rdf-syntax-ns%23%22%20xmlns:svg=%22http://www.w3.org/2000/svg%22%20xmlns=%22http://www.w3.org/2000/svg%22%20xmlns:sodipodi=%22http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd%22%20xmlns:inkscape=%22http://www.inkscape.org/namespaces/inkscape%22%20width=%2266%22%20height=%2266%22%20id=%22svg4911%22%20inkscape:version=%220.48.4%20r9943%20custom%22%20sodipodi:docname=%22resume.svg%22%3E%3Cdefs%20id=%22defs4913%22/%3E%3Csodipodi:namedview%20id=%22base%22%20pagecolor=%22%23ffffff%22%20bordercolor=%22%23666666%22%20borderopacity=%221%22%20inkscape:pageopacity=%220%22%20inkscape:pageshadow=%222%22%20inkscape:zoom=%223.959798%22%20inkscape:cx=%2246.442742%22%20inkscape:cy=%2224.878569%22%20inkscape:document-units=%22px%22%20inkscape:current-layer=%22layer1%22%20showgrid=%22false%22%20inkscape:window-width=%22877%22%20inkscape:window-height=%22652%22%20inkscape:window-x=%220%22%20inkscape:window-y=%2223%22%20inkscape:window-maximized=%220%22/%3E%3Cg%20inkscape:label=%22Layer%201%22%20inkscape:groupmode=%22layer%22%20id=%22layer1%22%20transform=%22translate(0,-986.36218)%22%3E%3Cpath%20inkscape:connector-curvature=%220%22%20style=%22fill:%23fff;stroke:none%22%20d=%22m13.063992%20986.86247c-3.1931038.0-5.774992%202.55117-5.774992%205.74428v53.48015c0%203.1931%202.5818882%205.775%205.774992%205.775h39.872016c3.193104.0%205.774992-2.5819%205.774992-5.775v-53.48015c0-3.19311-2.581888-5.74428-5.774992-5.74428H13.063992zm.06144%204.23909h7.188021c.955975.0%201.72021.76424%201.72021%201.72021v6.75797c0%20.95596-.764235%201.72026-1.72021%201.72026h-7.188021c-.955975.0-1.720211-.7643-1.720211-1.72026v-6.75797c0-.95597.764236-1.72021%201.720211-1.72021zm12.37937%206.26648h19.352366c.823803.0%201.474466.65067%201.474466%201.47447s-.650663%201.47449-1.474466%201.47449H25.504802c-.823804.0-1.505184-.65069-1.505184-1.47449.0-.8238.68138-1.47447%201.505184-1.47447zm-8.78536%209.92196h22.362734c.823804.0%201.505184.6814%201.505184%201.5052.0.8238-.68138%201.4745-1.505184%201.4745H16.719442c-.823803.0-1.474465-.6507-1.474465-1.4745s.650662-1.5052%201.474465-1.5052zm5.34494%204.9456h23.253556c.576664.0%201.044414.4677%201.044414%201.0444.0.5766-.46775%201.0137-1.044414%201.0137H22.064382c-.576664.0-1.044414-.4371-1.044414-1.0137.0-.5767.46775-1.0444%201.044414-1.0444zm-5.34494%207.8945h22.362734c.823804.0%201.505184.6814%201.505184%201.5052.0.8239-.68138%201.4745-1.505184%201.4745H16.719442c-.823803.0-1.474465-.6506-1.474465-1.4745.0-.8238.650662-1.5052%201.474465-1.5052zm5.34494%204.9457h23.253556c.576664.0%201.044414.4677%201.044414%201.0444.0.5766-.46775%201.0444-1.044414%201.0444H22.064382c-.576664.0-1.044414-.4678-1.044414-1.0444.0-.5767.46775-1.0444%201.044414-1.0444zm-5.34494%207.9252h22.362734c.823804.0%201.505184.6506%201.505184%201.4745.0.8238-.68138%201.5051-1.505184%201.5051H16.719442c-.823803.0-1.474465-.6813-1.474465-1.5051.0-.8239.650662-1.4745%201.474465-1.4745zm5.34494%204.9149h23.253556c.576664.0%201.044414.4677%201.044414%201.0444.0.5766-.46775%201.0444-1.044414%201.0444H22.064382c-.576664.0-1.044414-.4678-1.044414-1.0444.0-.5767.46775-1.0444%201.044414-1.0444z%22%20id=%22rect4801%22/%3E%3C/g%3E%3C/svg%3E">
<span>resume</span>
</a><a class="circle circle--small circle--right circle--bottom" href=mailto:julian.ceipek@gmail.com><img style=margin-bottom:-.2em src="data:image/svg+xml,%3Csvg%20xmlns:dc=%22http://purl.org/dc/elements/1.1/%22%20xmlns:cc=%22http://creativecommons.org/ns%23%22%20xmlns:rdf=%22http://www.w3.org/1999/02/22-rdf-syntax-ns%23%22%20xmlns:svg=%22http://www.w3.org/2000/svg%22%20xmlns=%22http://www.w3.org/2000/svg%22%20xmlns:sodipodi=%22http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd%22%20xmlns:inkscape=%22http://www.inkscape.org/namespaces/inkscape%22%20width=%2266%22%20height=%2266%22%20id=%22svg4855%22%20inkscape:version=%220.48.4%20r9943%20custom%22%20sodipodi:docname=%22contact.svg%22%3E%3Cdefs%20id=%22defs4857%22/%3E%3Csodipodi:namedview%20id=%22base%22%20pagecolor=%22%23ffffff%22%20bordercolor=%22%23666666%22%20borderopacity=%221%22%20inkscape:pageopacity=%220%22%20inkscape:pageshadow=%222%22%20inkscape:zoom=%222.8%22%20inkscape:cx=%2226.11611%22%20inkscape:cy=%2224.002165%22%20inkscape:document-units=%22px%22%20inkscape:current-layer=%22layer1%22%20showgrid=%22false%22%20inkscape:window-width=%221010%22%20inkscape:window-height=%22479%22%20inkscape:window-x=%220%22%20inkscape:window-y=%2223%22%20inkscape:window-maximized=%220%22/%3E%3Cg%20inkscape:label=%22Layer%201%22%20inkscape:groupmode=%22layer%22%20id=%22layer1%22%20transform=%22translate(0,-986.36218)%22%3E%3Cpath%20inkscape:connector-curvature=%220%22%20style=%22fill:%23fff;stroke:none%22%20d=%22m7.109375%20995.20588c-3.0902.0-5.5625%202.50355-5.5625%205.59372v.7812l.875.4689%2031.375%2016.6875%2029.4375-15.4688%201.21875-.625v-1.8438c0-3.09017-2.472303-5.59372-5.5625-5.59372zm-5.5625%2010.78132v31.9375c0%203.0902%202.4723%205.5938%205.5625%205.5938h51.78125c3.090197.0%205.5625-2.5036%205.5625-5.5938v-30.875l-29.75%2015.6563-.9375.4687-.90625-.5z%22%20id=%22rect4827%22%20sodipodi:nodetypes=%22sscccccssscssssccccc%22/%3E%3C/g%3E%3C/svg%3E">
<span>contact</span></a></footer></body></html>